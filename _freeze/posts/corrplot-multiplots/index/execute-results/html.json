{
  "hash": "9d846322f4c487c096b9124d1a6641e9",
  "result": {
    "markdown": "---\ntitle: \"How to make a figure with several panels that include plots that are initially invisible? The case of the {corrplot} package\"\ndescription: \"Multi-panel figure using plots from {corrplot}\"\nauthor: \"Pierre-Yves de Müllenheim\"\ndate: \"11/15/2022\"\nformat:\n  html:\n    code-fold: false\n    css: ../../css/posts.css\nexecute:\n  warning: false\n  cache: true\n  freeze: true\ntbl-cap-location: top\neditor: visual\ncategories:\n  - R\n  - Data visualization\n  - Correlation\nlink-citations: true\nimage: ../../docs/posts/corrplot-multiplots/index_files/figure-html/unnamed-chunk-9-1.png\n---\n\n\n\n# The problem\n\nSome days ago, I was contacted by a student who wanted to visualize several sets of correlation values on the same figure. Making a multi-panel figure using correlation plots produced from the [`{corrplot}`](https://github.com/taiyun/corrplot) package seemed an interesting option. However, I met several unexpected problems to get the desired result. In this post, I share the solutions I have found to finally get a good result after some time spent on the web.\n\nFirst, let's load the packages required for our analyses:\n\n::: {.cell hash='index_cache/html/unnamed-chunk-1_a3105974561a708e6953d9ef71f05c83'}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\nlibrary(dplyr)\nlibrary(corrplot)\nlibrary(ggplotify)\nlibrary(cowplot)\nlibrary(ragg)\n```\n:::\n\nSecond, let's get some data, here from the `{palmerpenguins}` package that provides physical characteristics of three species of penguins:\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_8b0de653c7e3254096f21c867ae67890'}\n\n```{.r .cell-code}\ndata(\"penguins\")\n```\n:::\n\nThird, let's compute correlation matrices putting into relation the physical characteristics for each of the three species of penguins:\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_5e6678a2faebd0ea3e811859c21d6194'}\n\n```{.r .cell-code}\n# Correlation matrix for 'Adelie' specie\nmat_adelie <- \n  penguins %>% \n  filter(species == \"Adelie\") %>%\n  select(bill_length_mm: body_mass_g) %>%\n  cor(use = \"pairwise.complete.obs\")\n  \n# Correlation matrix for 'Gentoo' specie\nmat_gentoo <- \n  penguins %>% \n  filter(species == \"Gentoo\") %>%\n  select(bill_length_mm: body_mass_g) %>%\n  cor(use = \"pairwise.complete.obs\")\n  \n# Correlation matrix for 'Chinstrap' specie\nmat_chinstrap <- \n  penguins %>% \n  filter(species == \"Chinstrap\") %>%\n  select(bill_length_mm: body_mass_g) %>%\n  cor(use = \"pairwise.complete.obs\")\n```\n:::\n\nThen, I thought we could simply assign the output of the `corrplot()` function from the `{corrplot}` package (i.e., the function that generates the correlation plot) to a name, say `p`, which could have allow me to use `p` when building the targeted multi-panel figure. Here the example for the correlation matrix related to the `Adelie` specie:\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_f66cc79e8c5662b7bcc857ab2d67e14d'}\n\n```{.r .cell-code}\np <-\n    corrplot(\n      mat_adelie, \n      method =\"color\", \n      type =\"lower\", \n      tl.col =\"black\",\n      addCoef.col = \"black\",\n      mar = c(0,0,0,0)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\nUnfortunately, this did not work. `p` did not return a plot, but the list of the information that were used when generating the plot:\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_d438cea4b1a962faf1a062b7ddbb4295'}\n\n```{.r .cell-code}\np\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$corr\n                  bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\nbill_length_mm         1.0000000     0.3914917         0.3257847   0.5488658\nbill_depth_mm          0.3914917     1.0000000         0.3076202   0.5761382\nflipper_length_mm      0.3257847     0.3076202         1.0000000   0.4682017\nbody_mass_g            0.5488658     0.5761382         0.4682017   1.0000000\n\n$corrPos\n               xName             yName x y      corr\n1     bill_length_mm    bill_length_mm 1 4 1.0000000\n2     bill_length_mm     bill_depth_mm 1 3 0.3914917\n3     bill_length_mm flipper_length_mm 1 2 0.3257847\n4     bill_length_mm       body_mass_g 1 1 0.5488658\n5      bill_depth_mm     bill_depth_mm 2 3 1.0000000\n6      bill_depth_mm flipper_length_mm 2 2 0.3076202\n7      bill_depth_mm       body_mass_g 2 1 0.5761382\n8  flipper_length_mm flipper_length_mm 3 2 1.0000000\n9  flipper_length_mm       body_mass_g 3 1 0.4682017\n10       body_mass_g       body_mass_g 4 1 1.0000000\n\n$arg\n$arg$type\n[1] \"lower\"\n```\n:::\n:::\n\nThe reason is that the plot is made \"invisible\" when it is provided by the `corrplot()` function, making it impossible to directly catch.\n\n# The solutions\n\nAt first glance, we could have decided to abandon the idea of using several graphic objects to be combined into a multi-panel figure, and then we could have stopped after the implementation of the following solution proposed on [Stack Overflow](https://stackoverflow.com/questions/27929452/r-return-corrplot-as-object):\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_c88a548541081a919433b0dbefe84ffa'}\n\n```{.r .cell-code}\npar(mfrow = c(1, 3))\ncorrplot(\n  mat_adelie, \n  method = \"color\", \n  type = \"lower\", \n  tl.col = \"black\",\n  addCoef.col = \"black\",\n  mar = c(0,0,0,0),\n  tl.cex = 2.5,\n  number.cex = 2.5\n  )\ncorrplot(\n  mat_gentoo, \n  method = \"color\", \n  type = \"lower\", \n  tl.col = \"black\",\n  addCoef.col = \"black\",\n  mar = c(0,0,0,0),\n  tl.cex = 2.5,\n  number.cex = 2.5\n  )\ncorrplot(\n  mat_chinstrap, \n  method = \"color\", \n  type = \"lower\", \n  tl.col = \"black\",\n  addCoef.col = \"black\",\n  mar = c(0,0,0,0),\n  tl.cex = 2.5,\n  number.cex = 2.5\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=1920}\n:::\n\n```{.r .cell-code}\npar(mfrow = c(1, 1)) # To clear layout\n```\n:::\n\nHowever, one could want to be able to catch the plot from the `corrplot()` function and to bind it to a name so that it can be used elsewhere in a more complex figure. What I have learnt is that it remains possible to do it by using a customized function that would return the last plot shown in the graphic device, as proposed on [Stack Overflow](https://stackoverflow.com/questions/65031113/how-to-save-a-plot-created-by-corrplot-function-in-r):\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_904a16e80e449dff4b3152c511876ad0'}\n\n```{.r .cell-code}\nget_corr_plot <- function(matrix) {\n  corrplot(\n    matrix,\n    method = \"color\", \n    type = \"lower\", \n    tl.col = \"black\",\n    addCoef.col = \"black\",\n    mar = c(0,0,0,0),\n    tl.cex = 2,\n    number.cex = 2\n    )\n\n  p <- recordPlot()\n\n  return(p)\n}\n```\n:::\n\nIn the code above, you will notice that the last plot is recorded thanks to the `recordPlot()` function from the `{grDevices}` package. The new problem is now that the function returns an object of class `recordedplot`, which is not yet really interesting to make complex figures as one could want to do with the `{cowplot}` package for example because the class `recordedplot` may not be accepted by the package functions. A solution is then to convert the `recordedplot` object to a `grob` object using the function `as.grob()` from the `{ggplotify}` package, as follows:\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_e801924dc36e508fb8c23e7ec3c1afaf'}\n\n```{.r .cell-code}\ngrob_adelie <- as.grob(~get_corr_plot(matrix = mat_adelie))\ngrob_gentoo <- as.grob(~get_corr_plot(matrix = mat_gentoo))\ngrob_chinstrap <- as.grob(~get_corr_plot(matrix = mat_chinstrap))\n```\n:::\n\nWe can finally use the `plot_grid()` function from the `{cowplot}` package to draw our final figure:\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_e2cd73add87536b820e42e669b019c6e'}\n\n```{.r .cell-code}\nfig <- plot_grid(grob_adelie, grob_gentoo, grob_chinstrap, nrow = 1, labels=LETTERS[1:3], label_size = 25)\nfig\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=1920}\n:::\n:::\n\n# The final touch\n\nThe graphic device may not always provide an approriate view of the figure. To have more control on this when we want to export the figure, we can use the `{ragg}` package as follows (maybe several trials and errors when manipulating the width, height, and scaling arguments will be needed to get satisfactory results; for more information, please see the [Thomas Lin Pedersen's post](https://www.tidyverse.org/blog/2020/08/taking-control-of-plot-scaling/)):\n\n::: {.cell hash='index_cache/html/unnamed-chunk-10_aaa18b7a0132438475de2ef16e10639f'}\n\n```{.r .cell-code}\nagg_png(\n  \"posts/corrplot-multiplots/index_files/figure-html/fig.png\", \n  width = 21, \n  height = 7, \n  units = \"cm\",\n  res = 300,\n  scaling = 0.4\n)\nfig\ndev.off()\n```\n:::\n\nEt voilà, we are done!\n\n# Session info\n\n::: {.cell hash='index_cache/html/unnamed-chunk-11_26d5e78ce86a2a7ba4bf9a0ea591c033'}\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.1 (2022-06-23 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19043)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=French_France.utf8  LC_CTYPE=French_France.utf8   \n[3] LC_MONETARY=French_France.utf8 LC_NUMERIC=C                  \n[5] LC_TIME=French_France.utf8    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ragg_1.2.3           ggplotify_0.1.0      cowplot_1.1.1       \n[4] corrplot_0.92        dplyr_1.0.10         palmerpenguins_0.1.1\n\nloaded via a namespace (and not attached):\n [1] pillar_1.8.1       compiler_4.2.1     yulab.utils_0.0.5  tools_4.2.1       \n [5] digest_0.6.29      jsonlite_1.8.3     evaluate_0.18      lifecycle_1.0.3   \n [9] tibble_3.1.8       gtable_0.3.1       pkgconfig_2.0.3    rlang_1.0.6       \n[13] cli_3.4.1          DBI_1.1.3          rstudioapi_0.14    yaml_2.3.6        \n[17] xfun_0.34          fastmap_1.1.0      stringr_1.4.1      knitr_1.40        \n[21] systemfonts_1.0.4  gridGraphics_0.5-1 generics_0.1.3     vctrs_0.5.0       \n[25] htmlwidgets_1.5.4  grid_4.2.1         tidyselect_1.2.0   glue_1.6.2        \n[29] R6_2.5.1           textshaping_0.3.6  fansi_1.0.3        rmarkdown_2.17    \n[33] ggplot2_3.4.0      magrittr_2.0.3     scales_1.2.1       htmltools_0.5.3   \n[37] assertthat_0.2.1   colorspace_2.0-3   utf8_1.2.2         stringi_1.7.8     \n[41] munsell_0.5.0     \n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}